$(":input, textarea, select, input").prop("readonly", true).attr("disabled", true).addClass("bg-gray/5 text-black/60")
$(".js-xaside-maximize-menu").prop("readonly", false).attr("disabled", false).removeClass("bg-gray/5 text-black/60")
import { generate_nft } from "./nft.js"

const modalButton = $(".js-cert-sign-blockchain-modal")

if ($(".js_cert_has_reciver").val() == 1) {
  if (modalButton.attr("data-reciver") === "1" && modalButton.attr("data-creator") === "1") {
    modalButton.prop("disabled", false).addClass("btn-neutral text-white")
    $(".js-cert-modal-tooltip").removeClass("tooltip")
  }
} else {
  if (modalButton.attr("data-creator") === "1") {
    modalButton.prop("disabled", false).addClass("btn-neutral text-white")
    $(".js-cert-modal-tooltip").removeClass("tooltip")
  }
}

$(".js-cert-sign-blockchain-modal").on("click", function () {
  let data = {}
  data.id = $(".js-cert-id").val()
  data.type = "cert"
  generate_nft(GLOBAL_AUTH_USER.id, "js-cert-node", $(".js-cert-token").html(), "certificate", "NFT Certificate", "Generated by Bnic.io", null, null, data)
})

$(function () {
  $("field.js-element input, field.js-element textarea, .js_additional_input").each(function () {
    if (typeof $(this).attr("placeholder") !== "undefined") {
      $(this).before(
        $("<div>", {
          text: $(this).attr("placeholder"),
        })
      )
    }
    //
  })
})

import * as FilePond from "filepond"
import FilePondPluginImagePreview from "filepond-plugin-image-preview"
import FilePondPluginPdfPreview from "filepond-plugin-pdf-preview"
import "filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css"

if ($(".file_upload_url").length > 0) {
  let filepond = $("<input>", {
    type: "file",
    class: "generated_file_pond w-full block rounded-lg ",
    value: $(".file_upload_url").val(),
  })
  $(".file_upload_url").before(filepond)
  FilePond.registerPlugin(FilePondPluginImagePreview)
  FilePond.registerPlugin(FilePondPluginPdfPreview)
  const inputElement = document.querySelector(".generated_file_pond")
  const pond = FilePond.create(inputElement, {})
  pond.addFile($(".file_upload_url").val())
  pond.setOptions({
    allowRevert: false,
    allowAdd: false,
    readOnly: true,
  })
}
let attachment = $(".js_cert_attachment_input")
attachment.prop("disabled", 0)
let attach_pond = null
console.log($(".js-cert-id").val())
axios
  .post(route("cert.attach_read"), {
    certificate_id: $(".js-cert-id").val(),
  })
  .then(function (response) {
    if (response.data.attachment != null) {
      const url = response.data.attachment
      console.log(url)
      const urlParts = url.split("/")
      const imageFilename = urlParts[urlParts.length - 1]
      attach_pond = FilePond.create(attachment[0], {
        server: {
          process: "/api/filepond/process",
          revert: "/api/filepond/revert",
          restore: "/restore",
          load: "/uploads/",
        },
        files: [
          {
            source: imageFilename,
            options: {
              type: "local",
            },
          },
        ],
      })
    } else {
      attach_pond = FilePond.create(attachment[0], {
        server: {
          url: "/api/filepond", // Update this to your Laravel API endpoint
          process: "/process",
          revert: "/revert",
          restore: "/restore",
          load: "/load",
        },
      })
    }

    attach_pond.on("processfile", (error, file) => {
      if (error) {
        console.error("File processing failed:", error)
        return
      }
      const response = JSON.parse(file.serverId)
      console.log(response.id)
      axios
        .post(route("cert.attach_document"), {
          attachment: response.id,
          certificate_id: $(".js-cert-id").val(),
        })
        .then(function (response) {
          console.log(response)
        })
    })
  })

function afterPond() {}
